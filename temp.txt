import logging
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, ContextTypes, ConversationHandler, MessageHandler, filters
import sqlite3
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
import asyncio
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)



# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –∏ –ø–æ–º–æ—â–∏
(START_CHOICE,  QUESTION_1, QUESTION_2, QUESTION_3, QUESTION_4, QUESTION_5,HELP, RESULT,REGISTRATION_STEP_1) = range(9)

# –í–æ–ø—Ä–æ—Å—ã –∏ –æ—Ç–≤–µ—Ç—ã
questions = [
    '–ß—Ç–æ –≤–∑—è—Ç—å –≤ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ?',
    '–¢–≤–æ–π –∏–¥–µ–∞–ª—å–Ω—ã–π –¥–µ–Ω—å?',
    '–¢–≤–æ–π –≤—ã–±–æ—Ä –æ—Ç–¥—ã—Ö–∞?',
    '–õ—é–±–∏–º–æ–µ –≤—Ä–µ–º—è –≥–æ–¥–∞?',
    '–¢–≤–æ–π —Å–ø–æ—Å–æ–± –ø–µ—Ä–µ–¥–≤–∏–∂–µ–Ω–∏—è?'
]

answers = [
    [['–ö–æ–º–ø–∞—Å –∏ –∫–∞—Ä—Ç–∞ üß≠', '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å'], 
     ['–ü—É—Ç–µ–≤–æ–¥–∏—Ç–µ–ª—å –∏ –æ—á–∫–∏ üìö', '–ú—É–¥—Ä–µ—Ü'], 
     ['–ö–æ—à–µ–ª–µ–∫ –∏ —Å—É–≤–µ–Ω–∏—Ä—ã üí∞', '–¢–æ—Ä–≥–æ–≤–µ—Ü']],
    [['–ü–æ—Ö–æ–¥ –Ω–∞ –Ω–µ–∏–∑–≤–µ–¥–∞–Ω–Ω–æ–µ üö∂‚Äç‚ôÇÔ∏è', '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å'], 
     ['–≠–∫—Å–∫—É—Ä—Å–∏—è –ø–æ –º—É–∑–µ—è–º üèõ', '–ú—É–¥—Ä–µ—Ü'], 
     ['–®–æ–ø–ø–∏–Ω–≥ –∏ —Ä—ã–Ω–∫–∏ üõçÔ∏è', '–¢–æ—Ä–≥–æ–≤–µ—Ü']],
    [['–ö–µ–º–ø–∏–Ω–≥ –≤ –ª–µ—Å—É üèïÔ∏è', '–ú–∏—Ä–æ–ª—é–±–µ—Ü'], 
     ['–ê–ª—å–ø–∏–Ω–∏–∑–º –∏ –¥–∞–π–≤–∏–Ω–≥ üßó‚Äç‚ôÇÔ∏è', '–ü—Ä–∏–∫–ª—é—á–µ–Ω–µ—Ü'], 
     ['–ü–ª—è–∂ –∏ –º–µ–¥–∏—Ç–∞—Ü–∏—è üèñÔ∏è', '–ú–∏—Ä–æ–ª—é–±–µ—Ü']],
    [['–õ–µ—Ç–æ, –ø–ª—è–∂–∏ –∏ —Å–æ–ª–Ω—Ü–µ ‚òÄÔ∏è', '–ú–∏—Ä–æ–ª—é–±–µ—Ü'], 
     ['–ó–∏–º–∞, –≥–æ—Ä—ã –∏ —Å–Ω–æ—É–±–æ—Ä–¥ üèÇ', '–ü—Ä–∏–∫–ª—é—á–µ–Ω–µ—Ü'], 
     ['–í–µ—Å–Ω–∞, –ø–∞—Ä–∫–∏ –∏ —Ü–≤–µ—Ç—ã üå∏', '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å']],
    [['–ü–µ—à–∫–æ–º –∏–ª–∏ –≤–µ–ª–æ—Å–∏–ø–µ–¥ üö¥', '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å'], 
     ['–ü–æ–µ–∑–¥–∞ –∏ –∞–≤—Ç–æ–±—É—Å—ã üöå', '–ú—É–¥—Ä–µ—Ü'], 
     ['–ê—Ä–µ–Ω–¥–æ–≤–∞–Ω–Ω–∞—è –º–∞—à–∏–Ω–∞ üöó', '–¢–æ—Ä–≥–æ–≤–µ—Ü']]
]
def save_user_data(user_id, username, character_class, image_path):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute("PRAGMA journal_mode=WAL")
    cursor.execute('''
    INSERT INTO users(user_id, username, class, image_path, speed, cunning, luck)
    VALUES(?,?,?,?,?,?,?)''', (user_id, username, character_class, image_path, 1, 1, 1))
    conn.commit()
    conn.close()
# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞—á–∞–ª–∞ –¥–∏–∞–ª–æ–≥–∞
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reply_keyboard = [['üß≠ –ù–∞—á–∞—Ç—å –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞', 'üÜò –ü–æ–ø—Ä–æ—Å–∏—Ç—å –ø–æ–º–æ—â—å']]
    await update.message.reply_text(
        '–ó–¥—Ä–∞–≤ –±—É–¥—å, –¥—Ä—É–∂–∏—â–µ! –ú–µ–Ω—è –∑–æ–≤—É—Ç –ê–ª–µ–∫—Å–∞–Ω–¥—Ä, –±–æ–≥–∞—Ç—ã—Ä—å –∏–∑ –¥–∞–ª–µ–∫–∏—Ö —Å—Ç—Ä–∞–Ω—Å—Ç–≤–∏–π. '
        '–°–ª—ã—à—É, —Ç—ã –≤ –ø–æ–∏—Å–∫–µ —Å–≤–æ–µ–≥–æ –ø—É—Ç–∏? –î–∞–≤–∞–π, –ø–æ–º–æ–≥—É –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å—Å—è, –∫–∞–∫–∏–µ –¥–æ—Ä–æ–≥–∏ —Ç–µ–±–µ –∏–¥—Ç–∏. '
        '–Ø —Ç–æ—á–Ω–æ –∑–Ω–∞—é –∫—É–¥–∞ —Ç–≤–æ—ë —Å–µ—Ä–¥—Ü–µ —Å—Ç—Ä–µ–º–∏—Ç—Å—è. –ê–ª–∏ –ø–æ–º–æ—â—å –≤ –ø—É—Ç–∏ –Ω—É–∂–Ω–∞? –ù–µ –±–æ–π—Å—è –≤—ã–±–æ—Ä–∞, '
        '–≤–µ–¥—å –∫–∞–∂–¥—ã–π —à–∞–≥ ‚Äì —ç—Ç–æ —á–∞—Å—Ç—å —Ç–≤–æ–µ–π –∏—Å—Ç–æ—Ä–∏–∏. –ü–æ–¥–µ–ª–∏—Å—å —Å–æ –º–Ω–æ–π —Å–≤–æ–∏–º–∏ –º–µ—á—Ç–∞–º–∏, '
        '–∏ –≤–º–µ—Å—Ç–µ –º—ã –Ω–∞–π–¥–µ–º —Ç–≤–æ–π –∏—Å—Ç–∏–Ω–Ω—ã–π –ø—É—Ç—å!',
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True),
    )
    return START_CHOICE
async def show_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    cursor.execute('SELECT username, class, image_path, speed, cunning, luck FROM users WHERE user_id = ?', (user_id,))
    user_data = cursor.fetchone()
    conn.close()

    if user_data:
        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Ñ–∏–ª–µ
        username, character_class, image_path, speed, cunning, luck = user_data
        message = f"–ò–º—è: {username}\n–ö–ª–∞—Å—Å: {character_class}\n–°–∫–æ—Ä–æ—Å—Ç—å: {speed}, –•–∏—Ç—Ä–æ—Å—Ç—å: {cunning}, –£–¥–∞—á–∞: {luck}"
        await update.message.reply_text(message)
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
        if image_path and os.path.exists(image_path):
            await update.message.reply_photo(photo=open(image_path, 'rb'))
        else:
            await update.message.reply_text("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.")
    else:
        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —ç—Ç–æ–º
        await update.message.reply_text("–ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω. –í—ã–ø–æ–ª–Ω–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É /register.")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
def is_user_registered(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute('SELECT 1 FROM users WHERE user_id = ?', (user_id,))
    user_exists = cursor.fetchone() is not None
    conn.close()
    return user_exists

async def register(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # –õ–æ–≥–∏–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await update.message.reply_text("–î–∞–≤–∞–π—Ç–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –≤–∞—Å! –ù–∞—á–Ω–µ–º —Å –≤—ã–±–æ—Ä–∞ –≤–∞—à–µ–≥–æ –∫–ª–∞—Å—Å–∞.")
    # –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏...
    return REGISTRATION_STEP_1
# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞
async def start_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.message.text
    user_id = update.message.from_user.id
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    if not is_user_registered(user_id):
        if query == 'üß≠ –ù–∞—á–∞—Ç—å –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞':
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
            return await register(update, context)
        elif query == 'üÜò –ü–æ–ø—Ä–æ—Å–∏—Ç—å –ø–æ–º–æ—â—å':
            return await help(update, context)
    else:
        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ –≤ –º–µ–Ω—é
        return await show_user_menu(update, context)

def is_user_registered(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute('SELECT 1 FROM users WHERE user_id = ?', (user_id,))
    user_exists = cursor.fetchone() is not None
    conn.close()
    return user_exists
async def start_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.message.text
    if query == 'üß≠ –ù–∞—á–∞—Ç—å –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞':
        reply_keyboard = [list(map(lambda x: x[0], answers[0]))]
        await update.message.reply_text(
            questions[0],
            reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True),
        )
        return QUESTION_1
    elif query == 'üÜò –ü–æ–ø—Ä–æ—Å–∏—Ç—å –ø–æ–º–æ—â—å':
        return await help(update, context)
async def registration_step_1(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:

    return await register(update, context)
# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –ø–æ–º–æ—â–∏
async def help(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        '–ù–µ –≤–æ–ª–Ω—É–π—Å—è, —è –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –ø–æ–º–æ—á—å —Ç–µ–±–µ! C–º–µ–ª–æ –∑–∞–¥–∞–≤–∞–π —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å!'
        # –î–æ–±–∞–≤—å—Ç–µ –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–ª–∏ —Å–æ–≤–µ—Ç—ã –∑–¥–µ—Å—å
    )
    return ConversationHandler.END

async def question_handler(update: Update, context: ContextTypes.DEFAULT_TYPE, question_number: int) -> int:
    user_answer = update.message.text
    for answer in answers[question_number - 1]:
        if user_answer == answer[0]:
            if 'results' not in context.user_data:
                context.user_data['results'] = {}
            context.user_data['results'][answer[1]] = context.user_data['results'].get(answer[1], 0) + 1
            break
    print(question_number)
    if question_number < len(questions):
        # –ï—Å–ª–∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å, –∑–∞–¥–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
        print(question_number)
        reply_keyboard = [list(map(lambda x: x[0], answers[question_number]))]
        await update.message.reply_text(
            questions[question_number],
            reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True),
        )
        print(question_number)
        return question_number + 1
    else:
        # –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≤—ã–≤–æ–¥—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        return await result(update, context)
async def send_notifications(bot):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute('SELECT user_id, class FROM users')
    users = cursor.fetchall()
    conn.close()

    for user_id, user_class in users:
        message = "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –≤–∞—Å!"
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª–∞—Å—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if user_class == "–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å":
            message = "–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏–µ –∂–¥–µ—Ç! –ì–æ—Ç–æ–≤—ã –∫ –Ω–æ–≤—ã–º –æ—Ç–∫—Ä—ã—Ç–∏—è–º?"
        elif user_class == "–ú—É–¥—Ä–µ—Ü":
            message = "–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –∫–≤–µ—Å—Ç –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –º—É–¥—Ä–µ—Ü–æ–≤!"
        # –î–æ–±–∞–≤—å—Ç–µ –¥—Ä—É–≥–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤
        
        try:
            await bot.send_message(chat_id=user_id, text=message)
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–≤–æ–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
async def result(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "Unknown"  # –ï—Å–ª–∏ username –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ "Unknown"
    final_class = max(context.user_data['results'], key=context.user_data['results'].get)
    photo_path = get_photo_path_based_on_class(final_class)
    
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    save_user_data(user_id, username, final_class, photo_path)
    
    await update.message.reply_photo(photo=open(photo_path, 'rb'), caption=f"–¢–≤–æ–π –∫–ª–∞—Å—Å: {final_class}")
    return ConversationHandler.END


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª–∞—Å—Å–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
def get_photo_path_based_on_class(character_class):
    images = {
        '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å': 'explorer.jpg',
        '–ú—É–¥—Ä–µ—Ü': 'sage.jpg',
        '–¢–æ—Ä–≥–æ–≤–µ—Ü': 'merchant.jpg',
        '–ü—Ä–∏–∫–ª—é—á–µ–Ω–µ—Ü': 'adventurer.jpg',
        '–ú–∏—Ä–æ–ª—é–±–µ—Ü': 'peacelover.jpg',
    }
    return images.get(character_class, "hermit.jpg")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã –¥–∏–∞–ª–æ–≥–∞
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('–û–ø—Ä–æ—Å –æ—Ç–º–µ–Ω–µ–Ω.', reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END
scheduler = AsyncIOScheduler()
def main():
    application = Application.builder().token("6564573865:AAFz0XogD4kPuoBsUqNq0PRbDs9ybn0i96E").build()


    conv_handler = ConversationHandler(
    entry_points=[CommandHandler('start', start)],
    states={
        START_CHOICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, start_choice)],
        QUESTION_1: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: question_handler(update, context, 1))],
        QUESTION_2: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: question_handler(update, context, 2))],
        QUESTION_3: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: question_handler(update, context, 3))],
        QUESTION_4: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: question_handler(update, context, 4))],
        QUESTION_5: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: question_handler(update, context, 5))],
                
        RESULT: [MessageHandler(filters.TEXT & ~filters.COMMAND, result)],
        HELP: [MessageHandler(filters.Regex('^(üÜò –ü–æ–ø—Ä–æ—Å–∏—Ç—å –ø–æ–º–æ—â—å)$'), help)],
        REGISTRATION_STEP_1: [MessageHandler(filters.TEXT & ~filters.COMMAND, registration_step_1)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],)

    
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler('register', register))
    application.add_handler(CommandHandler('menu', show_user_menu))
    scheduler = AsyncIOScheduler()
    scheduler.add_job(send_notifications, 'interval', seconds=130, args=[application.bot])
    scheduler.start()

    loop = asyncio.get_event_loop()
    loop.create_task(application.run_polling())
    loop.run_forever()

if __name__ == '__main__':
    main()    